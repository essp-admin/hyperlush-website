<!-- turntable.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Turntable</title>

  <link href="https://fonts.googleapis.com/css2?family=DM+Mono:wght@300;400;500&display=swap" rel="stylesheet">

  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #0a00db;
      overflow: hidden;
      font-family: "DM Mono", monospace;
    }

    canvas {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      cursor: pointer;
    }
  </style>
</head>

<body>
<canvas id="c"></canvas>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });

  // Buffer low-res para look 8-bit real
  const buf = document.createElement("canvas");
  const b = buf.getContext("2d", { alpha: true });

  // Ajusta esto: más alto = menos pixel
  const PIXEL = 6; // 5-8 suele ir bien en móvil y desktop

  const BLUE = "#0a00db";
  const WHT  = "#ffffff";
  const G1   = "#d6d6d6";
  const G2   = "#a8a8a8";
  const G3   = "#6e6e6e";
  const BLK  = "#111111";
  const RED  = "#d80000";

  let W = 0, H = 0;

  // Estado del mini flujo en 3 clicks
  // 0: aguja arriba (solo girando)
  // 1: aguja abajo (play)
  // 2: muestra texto "DO YOU WANT TO PLAY?"
  // 3: volver home
  let step = 0;

  // Rotación del vinilo
  let rot = 0;
  let last = performance.now();

  function resize() {
    canvas.width = Math.floor(window.innerWidth);
    canvas.height = Math.floor(window.innerHeight);

    buf.width = Math.max(1, Math.floor(canvas.width / PIXEL));
    buf.height = Math.max(1, Math.floor(canvas.height / PIXEL));

    W = buf.width;
    H = buf.height;

    b.imageSmoothingEnabled = false;
    ctx.imageSmoothingEnabled = false;
  }

  function pxRect(x, y, w, h, c) {
    b.fillStyle = c;
    b.fillRect(x|0, y|0, w|0, h|0);
  }

  function pxLineH(x, y, w, c) { pxRect(x, y, w, 1, c); }
  function pxLineV(x, y, h, c) { pxRect(x, y, 1, h, c); }

  function pxFrame(x, y, w, h, c) {
    pxLineH(x, y, w, c);
    pxLineH(x, y + h - 1, w, c);
    pxLineV(x, y, h, c);
    pxLineV(x + w - 1, y, h, c);
  }

  function pxTextCentered(text, y, scale=1) {
    b.save();
    b.fillStyle = WHT;
    b.textAlign = "center";
    b.textBaseline = "middle";
    // Tamaño en píxel: como estamos en buffer, mejor simple
    b.font = `${10 * scale}px "DM Mono", monospace`;
    b.fillText(text, (W / 2)|0, y|0);
    b.restore();
  }

  // Dibujo del tocadiscos estilo guía
  function drawTurntable(cx, cy) {
    // Caja exterior
    const boxW = Math.min(120, (W * 0.72)|0);
    const boxH = Math.min(90,  (H * 0.35)|0);

    const x0 = (cx - boxW/2)|0;
    const y0 = (cy - boxH/2)|0;

    // Base
    pxRect(x0, y0, boxW, boxH, BLUE);
    pxFrame(x0, y0, boxW, boxH, WHT);

    // Panel interno
    pxRect(x0+3, y0+3, boxW-6, boxH-6, BLUE);

    // Plato (círculo pixelado)
    const plateR = Math.min(30, (boxH * 0.34)|0);
    const plateX = x0 + (boxW * 0.38)|0;
    const plateY = y0 + (boxH * 0.52)|0;

    // Anillo exterior
    drawPixelCircle(plateX, plateY, plateR+4, WHT);
    drawPixelCircle(plateX, plateY, plateR+3, G2);
    drawPixelCircle(plateX, plateY, plateR+2, G3);

    // Vinilo
    drawPixelCircleFill(plateX, plateY, plateR+1, BLK);
    drawPixelCircle(plateX, plateY, plateR+1, G3);

    // Rayas tipo “reflejo” (dos sectores) para sensación de giro
    drawSpokes(plateX, plateY, plateR-2);

    // Label
    drawPixelCircleFill(plateX, plateY, 6, RED);
    drawPixelCircleFill(plateX, plateY, 2, WHT);

    // Botones simples (abajo izquierda)
    pxRect(x0+6, y0+boxH-14, 10, 8, WHT);
    pxRect(x0+18, y0+boxH-14, 16, 8, BLK);
    pxRect(x0+20, y0+boxH-12, 3, 2, WHT);
    pxRect(x0+25, y0+boxH-12, 3, 2, WHT);
    pxRect(x0+30, y0+boxH-12, 3, 2, WHT);

    // Selector derecha (vertical)
    pxFrame(x0+boxW-14, y0+boxH-28, 8, 20, WHT);
    pxRect(x0+boxW-12, y0+boxH-26, 4, 6, G2);
    pxRect(x0+boxW-12, y0+boxH-18, 4, 6, G3);

    // Dial arriba derecha
    drawPixelCircleFill(x0+boxW-22, y0+14, 8, WHT);
    drawPixelCircleFill(x0+boxW-22, y0+14, 5, G2);
    pxRect(x0+boxW-23, y0+13, 2, 6, BLK);

    // Aguja (según estado)
    // Posición tipo guía: lateral derecha, baja al vinilo
    const armBaseX = x0 + boxW - 22;
    const armBaseY = y0 + 26;

    // brazo
    if (step === 0 || step === 2) {
      // arriba, no toca el vinilo
      pxRect(armBaseX-2, armBaseY-2, 4, 4, WHT);
      pxRect(armBaseX-1, armBaseY-1, 2, 2, BLK);
      drawArm(armBaseX, armBaseY, plateX + plateR - 6, plateY - plateR + 6);
    } else {
      // abajo, tocando el vinilo
      pxRect(armBaseX-2, armBaseY-2, 4, 4, WHT);
      pxRect(armBaseX-1, armBaseY-1, 2, 2, BLK);
      drawArm(armBaseX, armBaseY, plateX + 8, plateY + 6);
      // “punta” en blanco
      pxRect(plateX + 7, plateY + 6, 2, 2, WHT);
    }
  }

  function drawArm(x1, y1, x2, y2) {
    // Línea pixelada sencilla tipo brazo
    const dx = x2 - x1;
    const dy = y2 - y1;
    const steps = Math.max(Math.abs(dx), Math.abs(dy));
    for (let i=0; i<=steps; i++) {
      const t = i/steps;
      const x = (x1 + dx*t) | 0;
      const y = (y1 + dy*t) | 0;
      pxRect(x, y, 1, 1, WHT);
      // grosor 2px en algunos puntos
      if ((i % 6) === 0) pxRect(x, y+1, 1, 1, WHT);
    }
  }

  function drawPixelCircle(cx, cy, r, col) {
    // contorno por muestreo angular
    for (let a=0; a<360; a+=3) {
      const rad = a * Math.PI / 180;
      const x = (cx + Math.cos(rad)*r) | 0;
      const y = (cy + Math.sin(rad)*r) | 0;
      pxRect(x, y, 1, 1, col);
    }
  }

  function drawPixelCircleFill(cx, cy, r, col) {
    // fill barato por scan
    for (let y=-r; y<=r; y++) {
      const w = Math.sqrt(r*r - y*y);
      const x0 = (cx - w) | 0;
      const x1 = (cx + w) | 0;
      pxRect(x0, cy+y, x1-x0+1, 1, col);
    }
  }

  function drawSpokes(cx, cy, r) {
    // 2 “reflejos” que rotan con el vinilo
    // usamos rot para desplazar el patrón
    const t = rot;
    for (let i=0; i<2; i++) {
      const ang = t + i*Math.PI;
      const x2 = (cx + Math.cos(ang) * r) | 0;
      const y2 = (cy + Math.sin(ang) * r) | 0;
      const x3 = (cx + Math.cos(ang + 0.7) * (r*0.65)) | 0;
      const y3 = (cy + Math.sin(ang + 0.7) * (r*0.65)) | 0;
      // trazo doble
      drawArm(cx, cy, x2, y2);
      drawArm(cx, cy, x3, y3);
      // repinta por encima para “suavizar” un poco el centro
      drawPixelCircleFill(cx, cy, 3, BLK);
      drawPixelCircleFill(cx, cy, 2, WHT);
    }
  }

  function drawOverlayText() {
    // Mensajito en grande centrado bajo el deck
    if (step >= 2) {
      const y = (H * 0.72) | 0;
      pxTextCentered("DO YOU WANT TO PLAY?", y, 1.2);
    } else {
      const y = (H * 0.72) | 0;
      pxTextCentered("CLICK TO INTERACT", y, 1.0);
    }

    // micro UI arriba izquierda (muy discreta)
    b.save();
    b.fillStyle = WHT;
    b.textAlign = "left";
    b.textBaseline = "top";
    b.font = `10px "DM Mono", monospace`;
    b.fillText("TURNTABLE", 8, 8);
    b.fillText("3 STEPS, THEN HOME", 8, 22);
    b.restore();
  }

  function tick(now) {
    const dt = Math.min(0.05, (now - last) / 1000);
    last = now;

    // gira más cuando la aguja está abajo
    const speed = (step === 1) ? 1.8 : 0.9;
    rot += dt * speed;

    // limpiar buffer
    b.clearRect(0, 0, W, H);

    // fondo azul sólido
    pxRect(0, 0, W, H, BLUE);

    // centro
    const cx = (W/2) | 0;
    const cy = (H*0.42) | 0;

    drawTurntable(cx, cy);
    drawOverlayText();

    // blit a pantalla sin smoothing
    ctx.imageSmoothingEnabled = false;
    ctx.fillStyle = BLUE;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(buf, 0, 0, canvas.width, canvas.height);

    requestAnimationFrame(tick);
  }

  function advance() {
    step++;

    if (step >= 3) {
      window.location.href = "index.html";
      return;
    }
  }

  // Click o space para avanzar
  document.addEventListener("click", (e) => {
    e.preventDefault();
    advance();
  }, { passive: false });

  document.addEventListener("keydown", (e) => {
    if (e.code === "Space" || e.key === " ") {
      e.preventDefault();
      advance();
    }
  });

  window.addEventListener("resize", resize);

  resize();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>


