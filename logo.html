<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Hyperlush</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #0a00db;
      overflow: hidden;
    }

    /* Canvas final a pantalla completa */
    canvas#rain {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;

      /* Clave para look pixel */
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
  </style>
</head>

<body>
  <canvas id="rain"></canvas>

  <script>
    const canvas = document.getElementById("rain");
    const ctx = canvas.getContext("2d", { alpha: false });

    // Canvas interno (baja resolución) para pixel look
    const buf = document.createElement("canvas");
    const bctx = buf.getContext("2d", { alpha: true });

    // Ajusta esto: más alto = menos pixel (más definido), más bajo = más 8-bit
    const PIXEL_SCALE = 6; // prueba 5–10

    // Lluvia: cantidad en función del tamaño del buffer
    let drops = [];
    let W = 0, H = 0;

    // Paleta 8-bit (blanco y “blanco sucio”)
    const COLOR_MAIN = "#ffffff";
    const COLOR_DIM  = "#cfd6ff";

    // “Spark” muy discreto, sin glow
    const SPARK_CHANCE_PER_FRAME = 0.01; // prueba 0.006–0.02
    const SPARK_FRAMES_MIN = 3;
    const SPARK_FRAMES_MAX = 7;

    function resize() {
      canvas.width = Math.floor(window.innerWidth);
      canvas.height = Math.floor(window.innerHeight);

      buf.width = Math.max(1, Math.floor(canvas.width / PIXEL_SCALE));
      buf.height = Math.max(1, Math.floor(canvas.height / PIXEL_SCALE));

      W = buf.width;
      H = buf.height;

      // Rebuild drops según tamaño
      createDrops();
    }

    function createDrops() {
      // Densidad: ajusta a gusto
      const total = Math.floor((W * H) / 90); // prueba /70 más lluvia, /120 menos
      drops = [];

      for (let i = 0; i < total; i++) {
        const len = 2 + (Math.random() * 6) | 0; // longitud en “píxeles”
        drops.push({
          x: (Math.random() * W) | 0,
          y: (Math.random() * H) | 0,
          len,
          speed: 1 + (Math.random() * 3) | 0, // 1..3
          bright: Math.random() < 0.35,        // mezcla blanco/dim
          spark: 0,
          sparkMax: 0
        });
      }
    }

    // Dibuja un “segmento” vertical pixel
    function drawDrop(d) {
      bctx.fillStyle = d.bright ? COLOR_MAIN : COLOR_DIM;

      // línea vertical 1px de ancho
      // se dibuja de y a y+len, clamp dentro del buffer
      const y0 = d.y;
      const y1 = d.y + d.len;

      // Si se sale por abajo, dibuja lo visible y lo demás al reaparecer
      if (y0 < H) {
        const drawLen = Math.min(d.len, H - y0);
        if (drawLen > 0) bctx.fillRect(d.x, y0, 1, drawLen);
      }

      // Spark: 1px o 2x2, muy “8-bit”
      if (d.spark > 0) {
        const t = 1 - (d.spark / d.sparkMax); // 0..1
        // alterna tamaño entre 1 y 2 para “parpadeo” sin glow
        const s = (t > 0.5) ? 2 : 1;

        bctx.fillStyle = COLOR_MAIN;

        // spark cerca de la “cabeza” o mitad alta
        const sy = (d.y + ((d.len * 0.3) | 0)) | 0;
        const sx = d.x;

        bctx.fillRect(sx, sy, s, s);

        d.spark--;
      }
    }

    function step() {
      // Fondo sólido en buffer
      bctx.clearRect(0, 0, W, H);

      for (const d of drops) {
        // activar spark
        if (d.spark <= 0 && Math.random() < SPARK_CHANCE_PER_FRAME) {
          d.sparkMax = SPARK_FRAMES_MIN + ((Math.random() * (SPARK_FRAMES_MAX - SPARK_FRAMES_MIN + 1)) | 0);
          d.spark = d.sparkMax;
        }

        drawDrop(d);

        // mover
        d.y += d.speed;

        // respawn
        if (d.y > H + 10) {
          d.y = -((Math.random() * 15) | 0);
          d.x = (Math.random() * W) | 0;
          d.len = 2 + ((Math.random() * 6) | 0);
          d.speed = 1 + ((Math.random() * 3) | 0);
          d.bright = Math.random() < 0.35;
          d.spark = 0;
          d.sparkMax = 0;
        }
      }

      // Pintar buffer escalado a pantalla, sin suavizado
      ctx.imageSmoothingEnabled = false;
      ctx.fillStyle = "#0a00db";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(buf, 0, 0, canvas.width, canvas.height);

      requestAnimationFrame(step);
    }

    // Click para volver a home
    document.addEventListener("click", () => {
      window.location.href = "index.html";
    });

    window.addEventListener("resize", resize);
    resize();
    step();
  </script>
</body>
</html>

